include "include/vec2.bzz"
include "include/string.bzz"
include "rrt-include/rrt-implementation.bzz"
include "drive-include/drive.bzz"

# RRT* constants
XDIM = 200.0
YDIM = 200.0
EPSILON = XDIM / 5 #10.0  # distance from newely sampled node
NUMNODES = 500  # max iterations
NUMNODES_C = 0  # current number of nodes
RADIUS = EPSILON * 0.75 #15.0   # radius to look for parent
ROOT_ID = -1
CURRENT_PATH_WAYPOINT = 0

# ROBOT constants (drive function should be updated)
R = 0.029112741
L = 0.127

# RUNTIME constants
CURRENT_WAYPOINT = 0
PATH_READY = 0

# MISC
SIM_SCALE = 200.0   # conversion for argos

# Drive functions
##########################################################

function follow_waypoints(){
    if(CURRENT_PATH_WAYPOINT < size(path_points)){
        var tmp_index = (size(path_points) - 1) - CURRENT_PATH_WAYPOINT
    	var target = {.x = path_points[tmp_index].x / SIM_SCALE, .y = path_points[tmp_index].y / SIM_SCALE}
        #log("Going to: ", CURRENT_PATH_WAYPOINT, " / ", size(path_points), ", ", target.x , ", ", target.y)

        # calculate taget orientation
    	var robot_target_vec = math.vec2.new(target.x - pose.position.x, target.y - pose.position.y)
    	var distance_to_target = math.vec2.dis(math.vec2.new(pose.position.x, pose.position.y), target)
    	var d_a = math.vec2.angle(robot_target_vec) - pose.orientation.yaw
        #log("Distance: ", distance_to_target)
        if(distance_to_target > 0.1){
    	   avanti(0.2, d_a)
        } else if (CURRENT_PATH_WAYPOINT < size(path_points)){
            CURRENT_PATH_WAYPOINT = CURRENT_PATH_WAYPOINT + 1
        }
    } else {
        goto(0.0, 0.0)
        PATH_READY = 0
        CURRENT_PATH_WAYPOINT = 0
        CURRENT_WAYPOINT = CURRENT_WAYPOINT + 1
    }
}



# BUZZ functions
##########################################################
function init() {

    waypoints = {
        .0 = {.wp = math.vec2.new(200.0, 0.0)},
        .1 = {.wp = math.vec2.new(0.0, 200.0)},
        .2 = {.wp = math.vec2.new(200.0, 200.0)},
        .3 = {.wp = math.vec2.new(0.0, 0.0)}
    }
}


function step() {
    if(PATH_READY == 0 and CURRENT_WAYPOINT < size(waypoints)){
        # get endpoints and initialize RRT*
        log("Waypoint: ", CURRENT_WAYPOINT)
        var start_point = math.vec2.new(pose.position.x * SIM_SCALE, pose.position.y * SIM_SCALE)
        var end_point = waypoints[CURRENT_WAYPOINT].wp
        rrt_init(start_point, end_point)
        # find the path (result is in "nodes")
        rrt()
        PATH_READY = 1
        path_points = print_solution(nodes, end_point)

    } else if (CURRENT_WAYPOINT < size(waypoints)){
        follow_waypoints()
    } else {
        goto(0.0, 0.0)
    }
}



function destroy() {
}
