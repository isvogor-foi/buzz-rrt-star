include "include/vec2.bzz"
include "include/string.bzz"
include "rrt-include/rrt-implementation.bzz"
include "drive-include/drive.bzz"
include "misc-include/misc.bzz"

# RRT* constants
XDIM = 400.0
YDIM = 400.0
EPSILON = XDIM / 10 #10.0  # distance from newely sampled node
NUMNODES = 500  # max iterations
NUMNODES_C = 0  # current number of nodes
RADIUS = EPSILON * 0.75 #15.0   # radius to look for parent
ROOT_ID = -1
CURRENT_PATH_WAYPOINT = 0
VERBOSE_DEBUG = 0
SAFE_RADIUS = 0.12 # distance from point to check collisions

# RUNTIME constants
CURRENT_WAYPOINT = 0
PATH_READY = 0

# Drive functions
##########################################################

function follow_waypoints(){
    if(CURRENT_PATH_WAYPOINT < size(path_points)){
        var tmp_index = (size(path_points) - 1) - CURRENT_PATH_WAYPOINT
        var tmp = to_argos(path_points[tmp_index])
        var target = { .x = tmp.x, .y = tmp.y }
        if(VERBOSE_DEBUG == 1) log("Going to: ", CURRENT_PATH_WAYPOINT, " / ", size(path_points), ", ", target.x , ", ", target.y)

        # calculate taget orientation
    	var robot_target_vec = math.vec2.new(target.x - pose.position.x, target.y - pose.position.y)
    	var distance_to_target = math.vec2.dis(math.vec2.new(pose.position.x, pose.position.y), target)
    	var d_a = math.vec2.angle(robot_target_vec) - pose.orientation.yaw

        if(VERBOSE_DEBUG == 1) log("Distance: ", distance_to_target)
        if(distance_to_target > 0.1){
    	   avanti(0.2, d_a)
        } else if (CURRENT_PATH_WAYPOINT < size(path_points)){
            CURRENT_PATH_WAYPOINT = CURRENT_PATH_WAYPOINT + 1
        }
    } else {
        goto(0.0, 0.0)
        PATH_READY = 0
        CURRENT_PATH_WAYPOINT = 0
        CURRENT_WAYPOINT = CURRENT_WAYPOINT + 1
    }
}



# BUZZ functions
##########################################################
function init() {
    waypoints = {
        .0 = {.wp = from_argos(math.vec2.new(1.0, 1.0))},
        .1 = {.wp = from_argos(math.vec2.new(-1.0, -1.0))},
        .2 = {.wp = from_argos(math.vec2.new(1.0, -1.0))},
        .3 = {.wp = from_argos(math.vec2.new(0.0, 0.0))},
        .4 = {.wp = from_argos(math.vec2.new(1.0, 0.0))},
        .5 = {.wp = from_argos(math.vec2.new(0.0, -1.0))},
        .6 = {.wp = from_argos(math.vec2.new(0.0, 1.0))},
        .7 = {.wp = from_argos(math.vec2.new(0.0, 0.0))}
    }

    # for now only box (w = h, not working well otherwise)
    obstacles = {
        .0 = {.x = 0.4, .y = 0.4, .w = 0.4, .h = 0.4},
        .1 = {.x = 0.4, .y = -0.4, .w = 0.4, .h = 0.4},
        .2 = {.x = -0.4, .y = 0.4, .w = 0.4, .h = 0.4},
        .3 = {.x = -0.4, .y = -0.4, .w = 0.4, .h = 0.4}
    }
}


function step() {
    if(PATH_READY == 0 and CURRENT_WAYPOINT < size(waypoints)){
        # get endpoints and initialize RRT*
        if(VERBOSE_DEBUG == 1) log("Waypoint: ", CURRENT_WAYPOINT)

        var start_point = from_argos(math.vec2.new(pose.position.x, pose.position.y))
        var end_point = waypoints[CURRENT_WAYPOINT].wp

        rrt_init(start_point, end_point)
        # find the path (result is in "nodes")
        rrt()
        PATH_READY = 1
        path_points = print_solution(nodes, end_point)

    } else if (CURRENT_WAYPOINT < size(waypoints)){
        follow_waypoints()
    } else {
        goto(0.0, 0.0)
    }
}



function destroy() {
}
